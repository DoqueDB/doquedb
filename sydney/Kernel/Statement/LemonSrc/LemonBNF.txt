
â–  Sydney ã§æ‰±ã† SQL ã® BNF ã®ãƒ¡ãƒ¢ã§ã™ã€‚

/////////////////////////////////////////////////////////////////////////////
/////	ToDo ãƒªã‚¹ãƒˆ

----- â˜… Lemon ã® ToDo ãƒªã‚¹ãƒˆ ----------------------------------------------

	00/09/25
		ãƒ»ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³æ§‹æ–‡å¯¾å¿œ

	00/09/12
		ãƒ»ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ¤œç´¢æ§‹æ–‡å¯¾å¿œ
			create table
				â˜†æ¸ˆ 09/14
			create index
				â˜†æ¸ˆ 09/12
			insert into
				â˜†æ¸ˆ 09/14
			select
				â˜†æ¸ˆ 09/12

	00/09/11
		ãƒ»ARRAY æ§‹æ–‡ã®å®Ÿè£…
		  <data type>
				â˜†æ¸ˆ 09/14
		  <element reference>
				â˜†æ¸ˆ 09/14
		  <array value expression>
				â˜†æ¸ˆ 09/14
		  <array value constructor>
				â˜†æ¸ˆ 09/14
		  Store Assignment
				â˜†ã‚­ãƒ£ãƒ³ã‚»ãƒ« 09/12

	00/08/29
		ãƒ»AlterAreaAction::getActionType() ã®å¤‰æ›´ã«ä¼´ã„ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’
		  ä¿®æ­£ã€‚
			â˜†æ¸ˆ 08/29

	00/08/28
		ãƒ»AlterAreaAction::getActionType() ã®å¤‰æ›´ã«ä¼´ã„ã€ã‚³ãƒ³ã‚¹ãƒˆãƒ©ã‚¯ã‚¿ã‚’
		  ä¿®æ­£ã€‚
			â˜†æ¸ˆ 08/28
		ãƒ»ãªã‚“ã¨ã‹ AREA OPTION ã« DEFAULT ã‚’æœ‰åŠ¹ã«ã™ã‚‹ã€‚
			â˜†æ¸ˆ 08/28

	00/08/24
		ãƒ»23 æ—¥è¿½åŠ åˆ†ã®ãƒ†ã‚¹ãƒˆ
			â˜†æ¸ˆ 08/24

	00/08/23
		ãƒ»Alter (Index, Database, Area) å¥ã‚’ä½œæˆã™ã‚‹
			â˜†æ¸ˆ 08/23
		ãƒ»Drop (Database, Index) å¥ã‚’ä½œæˆã™ã‚‹
			â˜†æ¸ˆ 08/23

----- â˜… Statement Object ã® ToDo ãƒªã‚¹ãƒˆ ----------------------------------

	00/09/25
		ãƒ»ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ

	00/09/12
		ãƒ»ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ¤œç´¢å¯¾å¿œã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆä½œæˆ
			create table
				â˜†æ¸ˆ 09/14
			create index
				â˜†æ¸ˆ 09/12
			insert into
				â˜†æ¸ˆ 09/14
			select
				â˜†æ¸ˆ 09/12

	00/09/11
		ãƒ»ARRAY æ§‹æ–‡ã«å¯¾å¿œã—ãŸã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å®Ÿè£… ã¾ã§
				â˜†æ¸ˆ 09/14

		ãƒ»Common::DataArrayData ã® LIMITã€æ¬¡æ•°ãƒã‚§ãƒƒã‚¯ã€ä»£å…¥I/F ã‚’è€ƒãˆã‚‹
		  09/20 ã¾ã§
				â˜†ã‚­ãƒ£ãƒ³ã‚»ãƒ« 09/12

	00/08/29
		ãƒ»AlterAreaAction::getActionType()ã®æˆ»ã‚Šå€¤ã«
			AryAll ã¨ AryElm ã‚’è¿½åŠ 
			â˜†æ¸ˆ 08/29

	00/08/28
		ãƒ»AlterAreaAction::getActionType()ã®æˆ»ã‚Šå€¤ã‚ˆã‚Š
			Modify ã‚’å‰Šé™¤ã€SingleModify, ArrayModify ã‚’è¿½åŠ ã€‚
			â˜†æ¸ˆ 08/28

	00/08/24
		ãƒ»23 æ—¥è¿½åŠ åˆ†ã®ãƒ†ã‚¹ãƒˆ
			â˜†æ¸ˆ 08/24

	00/08/23
		ãƒ»Alter (Index, Database, Area) ã«é–¢é€£ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹
			â†’ AlterIndexStatement, AlterIndexAction
				â˜†æ¸ˆ 08/23
			â†’ AlterDatabaseStatement, AlterDatabaseAction
				â˜†æ¸ˆ 08/23
			â†’ AlterAreaStatement, AlterAreaAction
				â˜†æ¸ˆ 08/23

		ãƒ»alter table ã®çœç•¥ AREA åã‚’ Identifier("DEFAULT") ã‹ã‚‰
		  Identifier() ã«å¤‰æ›´ã™ã‚‹ã€‚
				â˜†æ¸ˆ 08/23

		ãƒ»Drop Database, Drop Index ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ä½œæˆ
			â†’ DropDatabaseStatement
				â˜†æ¸ˆ 08/24
			â†’ DropIndexStatement
				â˜†æ¸ˆ 08/24

		ãƒ»ä¸Šè¨˜ã®ã‚¯ãƒ©ã‚¹ã«å†æ§‹ç¯‰ãƒ•ãƒ©ã‚°ã‚’è¨­å®šã™ã‚‹ã€‚
				â˜†æ¸ˆ 08/24

/////////////////////////////////////////////////////////////////////////////
/////	ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ¤œç´¢æ§‹æ–‡

	â— ãƒ†ãƒ¼ãƒ–ãƒ«ä½œæˆ (ã“ã“ã‚ˆã‚Š æŠœç²‹)
	create table CH(
		â€¦,
		FullTextData	ntext ARRAY[NO LIMIT],
		â€¦
	)

	â— ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ä½œæˆ

	ãƒ»ãƒ–ãƒ¼ãƒªã‚¢ãƒ³ã€ãƒ©ãƒ³ã‚­ãƒ³ã‚°æ¤œç´¢ç”¨
		create fulltext index CH on CH(FullTextData)

	ãƒ»ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ¤œç´¢å¯¾å¿œç”¨
		create fulltext index CH_SCT on CH(FullTextData) hint'sectionized'


	â— æŒ¿å…¥
	insert into CH(â€¦, FullTextData, â€¦) values(â€¦, ARRAY[?, ?, ?, â€¦], â€¦)

	ã‚»ã‚¯ã‚·ãƒ§ãƒ³ã¯ '?' ã®é…åˆ—ã§è¡¨ç¾ã—ã¾ã™ã€‚
	ã‚»ã‚¯ã‚·ãƒ§ãƒ³æ–‡ç« ã¯ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã‹ã‚‰æ¸¡ã•ã‚Œã‚‹ DataArrayData ä¸­ã«
	Common::StreamData ã® DataArrayData ã‚’è¨­å®šã—ã€'?' ã«å¯¾å¿œã•ã›ã¾ã™ã€‚

		æ³¨ï¼šCommon::StreamData ã¯æœªå®Ÿè£…ã§ã™ã€‚

	â— æ¤œç´¢
	select sectionized(CH.TEXT) from CH where CH.TEXT like 'tttt'


/////////////////////////////////////////////////////////////////////////////
/////	Drop Database
<drop database statement> ::= DROP DATABASE <identifier>

/////////////////////////////////////////////////////////////////////////////
/////	Database Area Option

<database area option> ::=
	<database area clause>

<database area clause> ::=
	AREA <database area option>

<database area option> ::=	[<area name>]
							[TABLE [<area name>]]
							[HEAP [<area name>]]
							[INDEX [<area name>]]
							[FULLTEXT [<area name>]]
							[LOGICALLOG [<area name>]]
							[PHYSICALLOG [<area name>]]

/////////////////////////////////////////////////////////////////////////////
/////	Table Area Option

<table area option> ::=
	<table area clause>

<table area clause> ::=
	AREA <table area option>

<table area option> ::= [<area name>]
						[HEAP <area name>]
						[INDEX <area name>]
						[FULLTEXT <area name>]

â€» Memo
	<table definition> ::= CREATE tableScopeClause TABLE tableName
						   tableConstantClause (tableelementList)
						   hint tableAreaOption

/////////////////////////////////////////////////////////////////////////////
/////	Alter Table

<alter table statement> ::=
	ALTER TABLE <table name> <alter table action>

<alter table action> ::=
	<set table area clause> |
	<drop table area clause>

<set table area clause> ::=
	SET <table area clause>

<drop table area clauses> ::=
	DROP <table area clause>

<table area clause> ::=
	AREA <table area option>

<table area option> ä¸Šè¨˜å‚ç…§

/////////////////////////////////////////////////////////////////////////////
/////	Index Area Option

<index area option> ::=
	<index area clause>
<index area clause> ::=
	AREA <index area option>

<index area option> ::= [<area name>]
						[PHYSICALLOG [<area option>]]
						[HINT AREA <character string literal>]

/////////////////////////////////////////////////////////////////////////////
/////	Alter Index

<alter index statement> ::=
	ALTER INDEX <index name> <alter index action>

<alter index action> ::=
	<set  index area clause> |
	<drop index area cluase>

<set index area clause> ::=
	SET <index area clause>

<drop index area cluase> ::=
	DROP <index area clause>

<index area clause>	 ä¸Šè¨˜å‚ç…§

/////////////////////////////////////////////////////////////////////////////
/////	Database Area Option

database area clause> ::=
	AREA <database area option>

<database area option> ::= [<area name>]
						   [TABLE [<area name>]]
						   [HEAP [<area name>]]
						   [INDEX [<area name>]]
						   [FULLTEXT [<area name>]]
						   [LOGICALLOG [<area name>]]
						   [PHYSICALLOG [<area name>]]

/////////////////////////////////////////////////////////////////////////////
/////	Alter Database

<alter database statement> ::=
	ALTER DATABASE <database name> <alter database action>

<alter database action> ::=
	<set  database area clause> |
	<drop database area clause>

<set  database area clause> ::=
	SET <database area clause>

<drop database area clause> ::=
	DROP <database area clause>

<database area clause>	ä¸Šè¨˜å‚ç…§

/////////////////////////////////////////////////////////////////////////////
/////	Alter Area

<alter area statement> ::=
	ALTER AREA <area name> <alter area action>

<alter area action> ::=
	<modify area definition>

<modify area definition> ::=
	MODIFY <modify area clause>

<modify area clause> ::= <area path element> |
						 <area path array> |
						 <new area specified path element>

<new area specified path element> ::=
	<left bracket> <numeric literal> <right bracket> <area path element>

	â€» ã‚µãƒ³ãƒ—ãƒ«
		//æ—¢å­˜ AREA
		create area AR1 array['d:\data', 'd:\text']
		create area AR2 'd:\db'

		//è¿½åŠ  and å‰Šé™¤
		è¨±å¯ã—ãªã„ã€‚
		ãƒ‘ã‚¹ã®æ•°ã¯å¤‰æ›´å‰ã¨å¾Œã¯å¤‰ã‚ã‚‰ãªã„ã€‚
		ä¸‹ä½ãƒ¢ã‚¸ãƒ¥ãƒ¼ãƒ«ï¼ˆExecutionï¼Ÿï¼‰ã§ãƒã‚§ãƒƒã‚¯ã€‚

		//å¤‰æ›´
		alter area AR1 modify aray['d:\syd\data', 'd:\syd\text']
		alter area AR2 modify 'd:\syd\db'

/////////////////////////////////////////////////////////////////////////////
/////	Create Area

<area definition> ::=
	CREATE AREA <area name> <area path>

<area name> ::= <identifier>

<area path> ::= (<area path elemnt> | <area path array>)

<area path element> ::= <literal>

<area path array> ::= <area path element>[,<area path element>,...]

/////////////////////////////////////////////////////////////////////////////
/////	Drop Area
<drop area> ::=
	DROP AREA <area name>

/////////////////////////////////////////////////////////////////////////////
/////	ARRAY å®£è¨€

<data type> ::=
	<predefined type>
  | <row type>
  | <user-defined type>
  | <reference type>
  | <collection type>

	<predefined type> ::=
	  <character string type>
	  [ CHARACTER SET <character set specification> ]
	| <national character string type>
	| <binary large object string type>
	| <bit string type>
	| <numeric type>
	| <boolean type>
	| <datetime type>
	| <interval type>

	<row type> ::=
	  ROW <row type body>
	<row type body> ::=
		<left paren>
		<field definition> [ { <comma> <field definition> }... ]
		<right paren>

	<reference type> ::=
	  REF <left paren> <referenced type> <right paren>
	  [ <scope clause> ]

	<referenced type> ::= <user-defined type>


	<collection type> ::=
	  <data type> <array specification>
	<array specification> ::=
	  <collection type constructor>
	  <left bracket or trigraph> <unsigned integer>
	  <right bracket or trigraph>
	<collection type constructor> ::=
	  ARRAY

	<empty specification> ::=
	  ARRAY <left bracket or trigraph> <right bracket or trigraph>

/////////////////////////////////////////////////////////////////////////////
/////	ARRAY ãƒ‡ãƒ¼ã‚¿

>> value expression
<value expression> ::=
	<numeric value expression>
  | <string value expression>
  | <datetime value expression>
  | <interval value expression>
  | <boolean value expression>
  | <user-defined type value expression>
  | <row value expression>
  | <reference value expression>
  | <collection value expression>

	<user-defined type value expression> ::=
	  <value expression primary>
	<reference value expression> ::=		// æœ¬å‘½
	  <value expression primary>			// æœ¬å‘½
	<collection value expression> ::=
	  <value expression primary>
	<value expression primary> ::=
		<parenthesized value expression>
	  | <nonparenthesized value expression primary>
	<parenthesized value expression> ::=
	  <left paren> <value expression> <right paren>
	<nonparenthesized value expression primary> ::=
		<unsigned value specification>
	  | <column reference>
	  | <set function specification>
	  | <scalar subquery>
	  | <case expression>

	• 1 alternative deleted.
	  | <cast specification>
	  | <subtype treatment>
	  | <attribute or method reference>
	  | <reference resolution>
	  | <collection value constructor>
	  | <routine invocation>
	  | <field reference>
	  | <element reference>
	  | <method invocation>
	  | <static method invocation>
	  | <new specification>

	• 1 alternative deleted.
	<collection value constructor> ::=
	  <array value expression>

	<element reference> ::=		 // ref. value expression
	  <array value expression> <left bracket or trigraph>
	  <numeric value expression> <right bracket or trigraph>

	ã€ä¾‹å¤–ã€‘<array value expression> ã«ã¯ <column reference> ã®ã¿ã‚’è¨±ã™ã€‚

	<array value expression> ::=
		  <array value constructor>
		| <value expression primary>	// ref. value expression

	<array value constructor> ::=
	  <array value list constructor>
	<array value list constructor> ::=
	  ARRAY <left bracket or trigraph> <array element list>
	  <right bracket or trigraph>
	<array element list> ::=
	  <array element> [ { <comma> <array element> }... ]
	<array element> ::=
	  <value expression>


	<value expression primary> ::=
		<column reference>
	/* omit
		<parenthesized value expression>
	  | <nonparenthesized value expression primary>
	<parenthesized value expression> ::=
	  <left paren> <value expression> <right paren>
	<nonparenthesized value expression primary> ::=
		<unsigned value specification>
	  | <column reference>
	  | <set function specification>
	  | <scalar subquery>
	  | <case expression>
	<unsigned value specification> ::=
		<unsigned literal>
	  | <general value specification>
	<general value specification> ::=
		<host parameter specification>
	  | <SQL parameter reference>
	<host parameter specification> ::=
	  <host parameter name> [ <indicator parameter> ]
	<indicator parameter> ::=
	  [ INDICATOR ] <host parameter name>
	<host parameter name> ::=
	  <colon> <identifier>
	<SQL parameter reference> ::=
	  <basic identifier chain>
	<identifier chain> ::=
	  <identifier> [ { <period> <identifier> }... ]
	<basic identifier chain> ::=
	  <identifier chain>
	<column reference> ::=
		<basic identifier chain>
	  | MODULE <period> <qualified identifier> <period> <column name>
	*/

	ã€ æœ€çµ‚æ¡ˆ
		<value expression> ::=
			  <element reference>
			| <array value expression>

		<array value constructor> ::=
			<array value list constructor>

		<array value list constructor> ::=
			ARRAY <left bracket> <array element list>
			<right bracket>

		<array element list> ::=
			<array element> [ { <comma> <array element> }... ]

		<array element> ::=
			<value expression>

		<value expression> ::=
			<literal>
	ã€

declared		å®£è¨€ã™ã‚‹
expression		è¡¨ç¾ èª¿å­
exact			æ­£ç¢ºãª å³å¯†ãª
specified		æ˜ç¢ºã« æŒ‡å®šã™ã‚‹
cardinality		æ¿ƒåº¦
otherwise		åˆ¥ã®æ–¹æ³•ã§ã¯
raise			ä¸Šã’ã‚‹ æ²ã’ã‚‹

immediately		ç›´ã¡ã« ç›´æ¥
contain			å«ã‚€ æŠ‘ãˆã‚‹
determine		æ±ºå¿ƒã™ã‚‹
apply			ç”³ã—è¾¼ã‚€ èã‹ã›ã‚‹
aggregation		é›†åˆ é›†ç´„

either			ã©ã¡ã‚‰ã‹ä¸€æ–¹ã®
comprising		â€¦ã‹ã‚‰æˆã‚‹ã€æ§‹æˆã™ã‚‹


2) The declared type of a <value expression primary> is the declared type of the immediately contained <unsigned value specification>, <column reference>, <set function specification>, <scalar subquery>, <case expression>, <value expression>, <cast specification>, <subtype treatment>, <attribute or method reference>, <reference resolution>, <collection value constructor>, <field reference>, <element reference>, <method invocation>, or <static method invocation>, or the effective returns type of the immediately contained <routine invocation>, respectively.

4.11.1 Arrays
An array is a collection A in which each element is associated with exactly one ordinal position in A.Ifn is the cardinality of A, then the ordinal position p of an element is an integer in the range 1 (one) <= p <= n. If EDT is the element type of A, then A can thus be considered as a function of the integers in the range 1 (one) to n onto EDT.
An array site AS has a maximum cardinality m. The cardinality n of an array occupying AS is constrained not to exceed m.
An array type is a <collection type>. If AT is some array type with element type EDT, then every value of AT is an array of EDT.
Let A1 and A2 be arrays of EDT. A1 and A2 are the same array if and only if A1 and A2 have the same cardinality n and if, for all i in the range 1 (one) <= i <= n, the element at ordinal position i in A1 is the same as the element at ordinal position i in A2.
Let n1 be the cardinality of A1 and let n2 be the cardinality of A2. A1 is a subarray of A2 if and only if there exists some j in the range 0 (zero) <= j < n2 such that, for every i in the range 1 (one) i <= n1, the element at ordinal position i in A1 is the same as the element at ordinal position i+j in
A2.

â–¡m.statement ã§ã®å®Ÿè£…
<collection type>
	ã€ä¾‹å¤–ã€‘	æ¬¡æ•°ãŒç„¡åˆ¶é™(NO LIMIT)ã®é…åˆ—å‹ã‚’å®šç¾©ã§ãã‚‹ã€‚

<element reference>
	ã€ä¾‹å¤–ã€‘	é¢å€’ã§ã‚ã‚Œã°ã€<numeric value expression> ã«ã¯
				<literal> ã—ã‹è¨±ã•ãªã„ã€‚

<array value expression>
	ã€ä¾‹å¤–ã€‘	<value expression primary> ã¨ã—ã¦
				<column reference> ã®ã¿ã‚’è¨±ã™ã€‚

<array value constructor>
	ã€ä¾‹å¤–	ã€‘	<array element> ã® <value expression> ã«ã¯
	<literal> ã¨ ? ã®ã¿ã‚’è¨±ã™ã€‚

/////////////////////////////////////////////////////////////////////////////
/////	ãƒˆãƒ©ãƒ³ã‚¶ã‚¯ã‚·ãƒ§ãƒ³

<start transaction statement> ::=
	START TRANSACTION <transaction mode> [ { <comma> <transaction mode> } ... ]

<transaction mode> ::=
	<isolation level> |
	<transaction access mode>

<transaction access mode> ::=
	READ ONLY |
	READ WRITE

<isolation level> ::=
	ISOLATION LEVEL <level of isolation>

<level of isolation> ::=
	READ UNCOMMITTED |
	READ COMMITTED |
	REPEATABLE READ |
	SERIALIZABLE

<set transaction statement> ::=
	SET TRANSACTION <transaction mode> [ { <comma> <transaction mode> } ... ]

<commit statement> ::=
	COMMIT [ WORK ]

<rollback statement> ::=
	ROLLBACK [ WORK ]

	//-----------------------------------------------------------------------
	Statment ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãƒ„ãƒªãƒ¼ã¯æ¬¡ã®æ§˜ã«æ§‹æˆã—ã¾ã™ã€‚
	<start transaction statement>
	(StartTransactionStatement
	 (TransactionMode
	  (TransactionAccessMode)	enumå€¤ { AccUnknown, ReadOnly, ReadWrite }
	  (LevelOfIsolation)		enumå€¤ { IsoUnknown,
							   ReadUncommitted, ReadCommitted,
							   RepeatableRead,	Serializable  }
	 )
	)

	<set transaction statement>
	(SetTransactionStatement
	 (StartTransactionStatement) ã¨åŒã˜
	)

	<commit statement>
	(CommitStatement)
	 ä¸­èº«ã¯ç‰¹ã«ç„¡ã—

	<rollback statement>
	(RollbackStatement)
	 ä¸­èº«ã¯ç‰¹ã«ç„¡ã—


/***************************************************************************/
>>>>>	Lisp å½¢å¼ã®å€¤

AlterAreaAction
	f_ActionType,
	f_AreaElementList

AlterAreaStatement
	f_AreaName,
	f_AlterAction,

AlterDatabaseAction
	f_ActionType,
		Unknown = 0,
		Set,
		Drop
	f_AreaOption,

AlterDatabaseStatement
	f_DatabaseName,
	f_AlterAction,

AlterIndexAction
	f_ActionType,
		Unknown = 0,
		Set,
		Drop
	f_AreaOption,

AlterIndexStatement
	f_IndexName,
	f_AlterAction,

AlterTableAction
	f_ActionType,
		Unknown = 0,
		Set,
		Drop
	f_AreaOption,

AlterTableStatement
	f_TableName,
	f_AlterAction,

AreaDataDefinition
	f_Path,
	f_Hint,

AreaDefinition
	f_Name,							// Area å
	f_Elements,						// ElementList

AreaOption
	f_default		= AreaOption::Default,
	f_table			= AreaOption::Table,
	f_heap			= AreaOption::Heap,
	f_index			= AreaOption::Index,
	f_fulltext		= AreaOption::FullText,
	f_logicallog	= AreaOption::LogicalLog,
	f_physicallog	= AreaOption::PhysicalLog,
	f_hint			= AreaOption::HintArea,

ColumnDefinition
	f_Name,
	f_DataType,
	f_DefaultValue,
	f_Hint,

ColumnName
	f_Identifier,

ColumnNameList
	f_ColumnName,

CursorName
	f_Identifier,

DataType
	f_DataType,
		NoType = 0,
		Char,					// ASCIIã®char (CHARç›¸å½“)
		NChar,					// Unicode char
		Int,
		Float,
		DateTime,				// æ—¥ä»˜ã€æ—¥æ™‚å‹
		UniqueIdentifier,		// ãƒã‚¤ã‚¯ãƒ­ã‚½ãƒ•ãƒˆæ‹¡å¼µå‹: Guid
		Binary,					// Binary
		Image,					// BLOBç›¸å½“: ç„¡åˆ¶é™å¯å¤‰é•·ãƒã‚¤ãƒŠãƒªæ–‡å­—åˆ—
		NText,					// ç„¡åˆ¶é™å¯å¤‰é•·Unicodeæ–‡å­—åˆ—
		Fulltext				// FTSå…¨æ–‡æ–‡å­—åˆ—

	f_Length,
	f_Flag,
		None = 0,
		Fixed,
		Variable,
		Unlimited
	f_Array						// -1 æ™‚ NOLIMIT

DeleteStatement
	f_TableReference,
	f_SearchCondition,
	f_CursorName,

DerivedColumn
	f_ValueExpression,
	f_ColumnName,

DropTableStatement
	f_Name,

DropTableStatement
	f_Name,

FromClause
	f_TableReferenceList,

FromClause
	f_TableReferenceList,

GroupByClause
	f_GroupingColumnReferenceList,

GroupingColumnReference
	f_ItemReference,

GroupingColumnReferenceList
	f_GroupingColumnReference,

HavingClause
	f_Condition,

Hint
	f_HintElement,

HintElement
	f_HintPrimary,

HintElementList
	f_HintElement,

Identifier
	f_Identifier,

IndexDefinition
	f_Name,
	f_TableName,
	f_ColumnNameList,
	f_IndexType,
		None = 0,
		Clustered,
		NonClustered,
		Inverted
	f_Hint,

InsertColumnsAndSource
	f_Query,
	f_ColumnList,

InsertStatement
	f_TableName,
	f_CursorName,
	f_QueryExpression,
	f_ColumnNameList,

ItemReference
	f_ItemQualifier,
	f_ItemName,

Literal
	f_DataType,
		None = 0,
		DatetimeStringLiteral,
		ExactNumericLiteral,
		ApproximateLiteral,
		CharacterStringLiteral
	f_Data,

NamedColumnsJoin
	f_ColumnList,

QualifiedJoin
	f_JoinType,
		None = 0,
		InnerJoin,
		NaturalJoin,
		LeftOuterJoin,
		RightOuterJoin,
		FullOuterJoin
	f_Left,
	f_Right,
	f_JoinSpecification,

QueryExpression
	f_QueryTerm,
	f_Operator,
	f_Next,

QueryOperator
	f_SetOperatorType,
		None = 0,
		Union,
		Except,
		Intersect
	f_All,
	f_CorrespondingSpec,

QuerySpecification
	f_Quantifier,
	f_SelectList,
	f_Table,
	f_SortSpecification,

QueryTerm
	f_QueryPrimary,

SelectList
	f_SelectSubListList,

SelectStatement
	f_QuerySpecification,

SelectSubList
	f_DerivedColumnOrIdentifier,

SelectSubListList
	f_SelectSubList,

SortSpecification
	f_SortKey,
	f_OrderingSpecification,
		Ascending = 0,
		Descending

SortSpecificationList
	f_SortSpecification,

SqlStatementList
	f_Statement,

TableConstraintDefinition
	f_ConstraintType,
		None = 0,
		PrimaryKey
	f_ColumnNameList,
	f_Clustered,

TableCorrelationSpec
	f_Correlation,
	f_Derived,

TableDefinition
	f_Name,
	f_Scope,
		Permanent = 0,			// æ°¸ç¶šçš„
		LocalTemporary,			// ã‚»ãƒƒã‚·ãƒ§ãƒ³å†…ä¸€æ™‚ãƒ†ãƒ¼ãƒ–ãƒ«
		GlobalTemporary			// å¤§åŸŸçš„ä¸€æ™‚ãƒ†ãƒ¼ãƒ–ãƒ«
	f_ConstUpdate,
		Updatable = 0,
		Constant
	f_Elements,
	f_InitialValue,
	f_Hint,

TableElementList
	f_TableElement,

TableExpression
	f_FromClause,
	f_WhereClause,
	f_GroupByClause,
	f_HavingClause,

TableReference
	f_Reference,
	f_CorrelationName,
	f_DerivedColumnList,
	f_Query,

TableReferenceList
	f_Object,

UpdateSetClause
	f_ColumnNameList,
	f_RowValue,

UpdateSetClauseList
	f_SetClause,

UpdateStatement
	f_TableReference,
	f_UpdateType,
		None = 0,
		All,
		Some
	f_SetClauseList,
	f_SearchCondition,
	f_CursorName,

ValueExpression
	f_Operator,
		op_List = 1,
		op_Literal,
		op_Nullobj,
		op_Itemref,
		op_Rowref,
		op_Arrayref,
		op_Rowconst,
		op_Tblconst,
		op_Arrayconst,
		op_Placeholder,
		op_ColumnName,
		op_Add = 31,
		op_Sub,
		op_Mul,
		op_Div,
		op_Neg,
		op_And = 41,
		op_Or,
		op_Not,
		op_String_concat = 51,
		op_Eq = 61,
		op_Ne,
		op_Le,
		op_Lt,
		op_Ge,
		op_Gt,
		op_Between,
		op_Like,
		op_Contains,
		op_IsNull,
		op_Exists,
		op_Func = 80
	f_ValueType,
		Unknown = 0,
		Numeric,
		String,
		Datetime,
		Interval,
		Enumerate,
		Boolean,
		Null,
		Row,
		Table,
		Array
	f_Constant,
	f_Left,
	f_Right,
	f_Option,
	f_Primary,
	f_Function,
		func_Unknown = 0,
		func_User,
		func_Session_User,
		func_Current_User,
		func_Current_Path,
		func_Value,
		func_Count,
		func_Avg,
		func_Max,
		func_Min,
		func_Sum
	f_Quantifier,
		quant_None = 0,
		quant_All,
		quant_Distinct

ValueExpressionList
	f_Constant,
	f_ValueExpression,

WhereClause
	f_Condition,
