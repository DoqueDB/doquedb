目次   

--------------------------------------------------------------------------------


Java 2 SDK 国際化の概要

--------------------------------------------------------------------------------


はじめに 
更新日:1999 年 12 月 2 日

全世界に広がるインターネットでは、世界中どこでも使えるソフトウェアが必要になります。つまり、ユーザの国や言語を意識しないで開発でき、さまざまな国や地域に合わせて地域対応できるソフトウェアです。Java 2 プラットフォームでは、グローバルアプリケーションを開発するための豊富な API 群が提供されています。このような国際化のための API は、Unicode 2.1 の文字エンコーディングに基づいており、テキスト、数値、日付、通貨、およびユーザ定義のオブジェクトを任意の国の慣習に合わせる機能を備えています。

このドキュメントでは、Java 2 プラットフォームの国際化に関する API と機能の概要を説明します。コーディング例と詳しい手順の説明については、『Java チュートリアル』を参照してください。API の詳細については、Java プラットフォーム API 仕様を参照してください。

詳細については、「国際化」を参照してください。


ロケール
Java プラットフォームでは、ロケールは、言語と地域の特定の組み合わせに対する単なる識別子です。ロケール固有の属性の集合ではありません。ロケール固有の情報は、ロケールの影響を受けるクラスがそれぞれ独自に保持しています。このような設計のため、ロケール固有のリソースを保持する方法に関し、ユーザオブジェクトとシステムオブジェクトで違いはありません。どちらも、標準の地域対応機構を使います。
Java プログラムには、単一のグローバルロケールは割り当てられていません。ロケールに依存するすべての操作には、引数として明示的にロケールを渡すことができます。これにより、多言語プログラムが非常に簡単になります。グローバルロケールが強制的に使われることはありませんが、ロケールを明示的に管理する必要のないプログラムでは、デフォルトのロケールを利用できます。デフォルトロケールを使うと、全体的な表示形式を一度の選択で変えることができます。

Java のロケールは、別のオブジェクトから出された、ある動作に対する要求として機能します。たとえば、カレンダオブジェクトにフランス語系カナダ用ロケールを渡すと、ケベック州の慣習に従って正しく動作するようカレンダに要求したことになります。ロケールを受け取ったオブジェクトは、適切な処理を行わなければなりません。オブジェクトが特定のロケールに対して地域対応されていない場合、オブジェクトは、地域対応されているロケールでよく似たものを探します。たとえば、カレンダオブジェクトがフランス語系カナダのロケール用に地域対応されていなくても、一般的なフランス語については地域対応されている場合は、代わりにフランス語の地域対応版を使います。


Locale クラス
Locale オブジェクトは、地理的、政治的、または文化的に特定の地域を表しています。動作するためにロケールを必要とする操作のことを、ロケール依存操作と呼びます。ロケール依存操作は、Locale オブジェクトを使って、ユーザに合うように情報を加工します。たとえば、数値の表示はロケールに依存する操作です。数値の書式は、ユーザに固有の国、地域、文化などの慣習やきまりに従って設定する必要があります。 

サポートされているロケール
Java プラットフォームでは、クラスごとに独自の地域対応版が保持されるので、サポートされるロケールの集合は 1 種類だけでなくてもかまいません。ただし、Java 2 プラットフォームのクラスとしては、一貫性のある地域対応をサポートしています。Java プラットフォームのほかの実装では、異なるロケールをサポートする場合があります。Java 2 SDK がサポートするロケールの一覧は、「サポートされているロケール」を参照してください。Java 2 SDK の今後のリリースでは、新しいロケールが追加される可能性があります。

地域対応されたリソース
すべてのロケール依存クラスは、サポートするロケール用にカスタマイズされたリソースにアクセスできなければなりません。地域対応の処理を容易にするには、ロケールごとにリソースをグループ化し、プログラムのロケールに依存しない部分から切り離すことが有用です。 

ResourceBundle クラス
ResourceBundle クラスは、リソースのコンテナを表す抽象基底クラスです。プログラムでは、特定のロケールのためのリソースを含む ResourceBundle のサブクラスを作成します。使用するコードを変更しなくても、ResourceBundle のインスタンスに新しいリソースを追加したり、ResourceBundle の新しいインスタンスをシステムに追加したりできます。リソースをクラスとしてパッケージ化することで、Java のクラスローディング機構を利用してリソースを探すことができます。
リソースのバンドルには、ロケール固有のオブジェクトが含まれています。String オブジェクトなど、ロケール固有のリソースが必要な場合は、現在のユーザのロケールに適したリソースバンドルからリソースをロードします。このようにして、リソースのバンドルに含まれているロケール固有の情報のすべて、または少なくとも大部分を切り離し、ユーザのロケールとの依存関係が弱いコードを作成できます。

次のような特徴を備えた Java コードを作成できます。 


別の言語に簡単に地域対応つまり翻訳できる


複数のロケールを同時に扱うことができる


あとから新しいロケールのサポートを簡単に追加できる


ListResourceBundle クラス
ListResourceBundle クラスは ResourceBundle クラスの抽象サブクラスで、便利で使いやすい一覧を利用して、ロケールのリソースを管理します。

PropertyResourceBundle クラス
PropertyResourceBundle クラスは ResourceBundle クラスを具体化したサブクラスで、プロパティファイルから取り出した固定文字列群を利用して、ロケールのリソースを管理します。

カレンダとタイムゾーンのサポート
JDK ソフトウェアの Version 1.0 では、日付と時刻を表すために java.util.Date クラスが導入されました。java.util.Date クラスを使うと、年、月、日、時、分、秒の値として日付を解釈でき、日付の文字列の書式指定と構文解析が可能でした。しかし、これらの機能の API は国際化の対象にはなりませんでした。このクラスの「表現」部分だけが、JDK ソフトウェアの Version 1.1 に引き継がれています。
JDK ソフトウェア 1.1 のリリースでは、Date クラスは、日付または時刻のラッパーとしてだけ使う必要があります。つまり、Date オブジェクトは、ミリ秒の単位で時刻の具体的なインスタンスを表します。代わりに、日付と時刻のフィールドの間の変換には Calendar クラスを、また日付の文字列の書式指定と構文解析には DateFormat クラスを、それぞれ使う必要があります。JDK ソフトウェアの Version 1.0 で使われていた Date クラスの対応するメソッドは、推奨されなくなっています。


Calendar クラス
Calendar クラスは抽象基底クラスで、内部時間 (1970 年 1 月 1 日 00:00:00 GMT からの経過時間をミリ秒で表したもの) と年、月、週などを表す整数値の間の変換を行うことができます。GregorianCalendar クラスは Calendar クラスを具体化したサブクラスで、グレゴリオ暦 (太陽暦) の規則に従ってこの処理を行います。
Calendar クラスとそのサブクラスは、時刻の値をさまざまな方法で操作するときに便利です。Calendar オブジェクトのフィールドと結果として得られた日付に対して、数値演算を行うことができます。Calendar オブジェクトでは、特定の言語とカレンダのスタイルに対する日付と時刻の書式指定を実装するために必要なすべての時刻フィールドの値を生成できます。


TimeZone クラス
抽象クラスの TimeZone は、UTC (万国標準時) からのタイムゾーンのオフセットと使用可能なサマータイムのオフセットを、カプセル化しています。SimpleTimeZone クラスは具体化されたサブクラスで、サマータイムについての簡単な規則をカプセル化しています。これらの規則では、サマータイムに影響する法律の時系列的な変化は考慮されていません。Calendar クラスとそのサブクラスは、TimeZone クラスと SimpleTimeZone クラスを使って、現地時間と UTC の間の変換を行います。UTC は、Date オブジェクトが使う内部表現です。ほとんどのプログラムでは、TimeZone オブジェクトを直接扱う必要はありません。

書式指定
データを出力するときの書式指定には、多くの文化的な慣習が適用されます。数値、日付、時刻、およびメッセージのすべてについて、書式を指定してからでないと表示できない場合があります。Java プラットフォームでは、柔軟性のある書式指定クラス群が提供されており、ロケールの標準的な書式および独自に定義された書式の両方を扱うことができます。これらの書式指定クラスを使うと、書式を設定された文字列の構文を解析して、構成するオブジェクトに戻すこともできます。

Format クラス
Format クラスは、日付、時刻、メッセージ、数値など、ロケールに依存する情報の書式を指定する機能のための、抽象基底クラスです。 主要なサブクラスとして、DateFormat、NumberFormat、および MessageFormat の 3 つが提供されています。これら 3 つのクラスでは、それぞれ独自のサブクラスが提供されています。

DateFormat クラス
日付と時刻は内部的にはロケールに依存しない方法で格納されますが、ロケールを反映した形式で表示できるよう書式を指定する必要があります。たとえば、次は同じ日付に対する異なる書式の例です。

November 3, 1997 (英語)


3 novembre 1997 (フランス語)


DateFormat クラスは、ロケールに依存しない方法で日付と時刻の値の書式指定と構文解析を行うための、抽象基底クラスです。特定のロケールに対する時刻の標準書式を取得するための static ファクトリメソッドがいくつか用意されています。
DateFormat オブジェクトは、Calendar オブジェクトと TimeZone オブジェクトを使って、時刻の値を解釈します。デフォルトでは、特定のロケールに対する DateFormat オブジェクトは、そのロケールに対する適切な Calendar オブジェクトとシステムのデフォルトの TimeZone オブジェクトを使います。これらの設定は、必要に応じてオーバーライドできます。


SimpleDateFormat クラス
SimpleDateFormat クラスは具体化されたクラスで、ロケールに依存する方法で日付と時刻の書式指定と構文解析を行います。このクラスを使うと、書式指定 (ミリ秒をテキストに)、構文解析 (テキストをミリ秒に)、および正規化を行うことができます。

DateFormatSymbols クラス
DateFormatSymbols クラスは、月の名前、曜日の名前、時刻、タイムゾーンのデータなど、日付と時刻の書式指定に関する地域対応の可能なデータのカプセル化に使います。DateFormat クラスと SimpleDateFormat クラスはどちらも、DateFormatSymbols クラスを使ってこの情報をカプセル化します。
通常、プログラムで DateFormatSymbols クラスを直接使うことはありません。実際には、DateFormat クラスのファクトリメソッドで、書式指定の機能を実装します。 


NumberFormat クラス
NumberFormat クラスは、数値データの書式指定と構文解析のための抽象基底クラスです。異なる種類のロケール固有の数値書式を取得するため、static ファクトリメソッドがいくつか用意されています。
NumberFormat クラスは、任意のロケールで数値の書式指定と構文解析を行うときに役に立ちます。このクラスを使うコードは、小数点、桁区切り、使われている特定の 10 進数字、または数値の書式が 10 進数かどうかなどに対するロケールの規則から、完全に独立しています。通常の 10 進数、通貨、パーセントなどで数値を表示することもできます。 


1234.5 (10 進数値)


$1,234.50 (米国通貨)


Fr1.234,5 (フランス通貨)


123450% (パーセント)


DecimalFormat クラス
数値は、内部的にはロケールに依存しない方法で格納されていますが、ロケールを反映した形式で表示できるよう書式を指定する必要があります。たとえば、「#,###.00」というパターンを使うと、同じ数値でも次のように異なる書式になる場合があります。

1.234,56 (ドイツ語)


1,234.56 (英語)


DecimalFormat クラスは、NumberFormat クラスを具体化したサブクラスで、10 進数値の書式指定を行うことができます。通常、このクラスのインスタンスを直接生成することはありませんが、提供されているファクトリメソッドは使います。
DecimalFormat クラスには、数値の書式設定方法を指定するパターン文字列を受け取る機能があります。パターンでは、数値の精度、先頭の 0 を表示するかどうか、使用する通貨記号などの属性を指定します。プログラムで独自の書式を作る必要がある場合は、パターン文字列を変更できます。 


DecimalFormatSymbols クラス
DecimalFormatSymbols クラスは、数値の書式を指定するときに DecimalFormat が必要とする記号群 (小数点、グループ化区切り文字など) を表します。DecimalFormat クラスは、それ自体のために、ロケールデータから DecimalFormatSymbols クラスのインスタンスを生成します。これらの記号のどれかを変更する必要がある場合は、DecimalFormat オブジェクトから DecimalFormatSymbols オブジェクトを取得して修正できます。 

ChoiceFormat クラス
ChoiceFormat クラスは、NumberFormat クラスを具体化したサブクラスです。ChoiceFormat クラスを使うと、ある範囲の数値に書式を設定できます。このクラスは、通常、MessageFormat オブジェクトの中で複数形を処理するときに使われます。詳細については、次の「MessageFormat クラス」を参照してください。

MessageFormat クラス
プログラムでは、一連の文字列、数値、およびほかのデータからメッセージを作らなければならない場合がよくあります。たとえば、ディスクドライブにあるファイルの数を表示するメッセージのテキストは、状況によって次のように変わります。

The disk C contains 100 files.


The disk D contains 1 file.


The disk F contains 0 files.


一連の文字列と数値で作成されるメッセージがハードコードされている場合は、ほかの言語に変換できません。たとえば、次の例で、パラメータの「3」と「G」の位置が違うことに注意してください。

The disk G contains 3 files.(英語)


Il y a 3 fichiers sur le disque G. (フランス語)


MessageFormat クラスを使うと、言語に依存しない方法で、文字や数字を連結したメッセージを作成できます。MessageFormat オブジェクトは、複数のオブジェクトを受け取り、書式を設定して、パターンの適切な位置に書式を設定した文字列を挿入します。 

ParsePosition クラス
ParsePosition クラスを使って、Format クラスとそのサブクラスは構文解析を行なっている間の現在位置の軌跡を保持します。Format クラスの parseObject() メソッドでは、引数として ParsePosition オブジェクトが必要です。 

FieldPosition クラス
FieldPosition クラスを使って、Format クラスとそのサブクラスは書式指定された出力のフィールドを識別します。Format クラスの format() メソッドの 1 つでは、引数として FieldPosition オブジェクトが必要です。 

ロケールに依存する文字列の操作
プログラムでは、文字列の操作が頻繁に必要になります。文字列に対する共通の操作として、検索とソートがあります。文字列の照合やテキストのさまざまな境界の検出など、ある種の処理は、正確に行おうとすると非常に難しく、複数の言語を考慮する必要がある場合はさらに困難になります。Java 2 プラットフォームでは、このような共通の文字列操作の多くをロケールに依存した方法で処理するためのクラス群が提供されています。 

Collator クラス
Collator クラスでは、ロケールに依存した文字列の比較が行われます。自然言語テキストのための検索ルーチンおよびアルファベット順ソートルーチンを作るには、このクラスを使います。Collator は抽象基底クラスです。サブクラスでは、具体的な照合方法が実装されます。現在、Java 2 プラットフォームでは 1 つのサブクラス RuleBasedCollator が提供されており、広範な言語群に適用できます。ほかのサブクラスを作成し、さらに特別なニーズを扱うことができます。 

RuleBasedCollator クラス
RuleBasedCollator クラスは、Collator クラスを具体化したサブクラスで、データ駆動の簡単なテーブル照合機能を提供します。RuleBasedCollator クラスを利用し、目的に合わせてカスタマイズしたテーブルベースの照合機能を作成できます。たとえば、大文字、アクセント、および Unicode 複合文字を無視 (または意識) する照合機能を作ることができます。

CollationElementIterator クラス
CollationElementIterator クラスは、多国語文字列の各文字を処理するときの反復子として使われます。反復子は、位置付けされた文字の順序の優先順位を返すために使われます。文字の順序の優先順位つまりキーは、特定の Collator オブジェクトの中で文字を照合する方法を定義するものです。CollationElementIterator クラスは、RuleBasedCollator クラスの compare() メソッドで使われます。

CollationKey クラス
CollationKey オブジェクトは、特定の Collator オブジェクトの規則が適用される文字列を表します。2 つの CollationKey オブジェクトを比較すると、それらが表す文字列の相対的な順序が返されます。CollationKey オブジェクトを使って文字列を比較する方が、一般に、Collator.compare() メソッドを使うより高速です。したがって、文字列の一覧をソートするときのように、文字列を比較する回数が多い場合は、CollationKey オブジェクトを使う方が効率的です。 

BreakIterator クラス
BreakIterator クラスは、テキストの文字列の中から次の種類の境界の位置を見つけるためのメソッドを間接的に実装します。

潜在的な行ブレーク


文


語


文字


行、文、語、および文字を区切る場所の規則は、言語の種類により異なります。BreakIterator クラスはロケールに依存するので、テキストを操作するプログラムで使うことができます。たとえば、文字の強調表示、語の切り取り、次の文へのカーソルの移動、行末での折り返しなどが可能なワープロプログラムを考えます。このワープロプログラムは、ブレーク反復子を使ってテキストの論理的な境界を決定し、ロケールを意識した方法でテキストを操作できるようにします。

StringCharacterIterator クラス
StringCharacterIterator クラスは、Unicode 文字の文字列に対して双方向の反復処理を行う機能を提供します。このクラスは、カーソルを使ってある範囲のテキストの中を移動し、個別の文字または文字のインデックス値を返すことができます。StringCharacterIterator クラスは、CharacterIterator インタフェースの文字反復子機能を実装しています。 

CharacterIterator インタフェース
CharacterIterator インタフェースは、Unicode 文字に対する双方向の反復処理のためのプロトコルを定義しています。ある範囲のテキストの中を移動し、個別の Unicode 文字またはそのインデックス値を返すクラスの場合、このインタフェースを実装する必要があります。CharacterIterator は、文字検索を行うときに役に立ちます。 

文字セットの変換
Java プラットフォームは、ネイティブの文字エンコーディングとして Unicode を使っていますが、Java プログラムの多くでは、まだ、ほかのエンコーディングのテキストデータを扱う必要があります。そのため、Java では、多くの標準的な文字エンコーディングと Unicode の間の変換を行うクラス群が提供されています。Unicode 以外のテキストデータを扱う必要がある Java プログラムは、通常、データをいったん Unicode に変換し、Unicode でデータを処理してから、結果を変換して外部の文字エンコーディングに戻します。InputStreamReader クラスと OutputStreamWriter クラスでは、ほかの文字エンコーディングと Unicode の間の変換を行うメソッドが提供されています。

サポートされているエンコーディング
InputStreamReader、OutputStreamWriter、String の各クラスでは、Unicode と「サポートされているエンコーディング」の一覧に示されている文字エンコーディングの間の変換が可能です。

AWT の属性 
プログラムの GUI の国際化を補助するため、Java 2 プラットフォームでは、2 つの属性 Name と Locale が Component クラスに提供されています。

Name 属性
Name 属性は、Component オブジェクトに対する地域対応しない識別子として機能する String オブジェクトです。Component クラスおよびそのサブクラスの新しいコンストラクタでは、Name 属性を設定できます。新しいコンストラクタを使わない場合は、デフォルトの Name が Component オブジェクトに割り当てられます。Component.getName() メソッドを使うと、Component オブジェクトの Name 属性を調べることができます。
Name 属性は、事前にターゲットの参照がわからないアクション処理ルーチンを作成するときに役に立ちます。この種のアクションハンドラは、GUI を作るときにしばしば生成されます。これまで、このようなルーチンは、Component のラベル文字列を見てターゲットを識別しようとしました。この方法では、ラベルの文字列が地域対応されていると目的を達成できませんでした。JDK ソフトウェアの 1.1 のリリースでは、代わりに Component.getName() メソッドを使う必要があります。


Locale 属性
Component クラスには、Locale 属性が追加されています。この属性は、getLocale() 系メソッドと setLocale() 系メソッドが利用します。Component オブジェクトの Locale メソッドが明示的に設定されていない場合、Component オブジェクトの親の Locale がデフォルトとして設定されます。Locale が明示的に設定された Component が階層内にない場合、Locale.getDefault() の値がデフォルトになります。
Component の Locale 属性を使うと、GUI (または GUI の一部) で独自のデフォルトロケールを保持できます。この機能は、たとえば、米国ロケールを使うブラウザの中で 1 つだけ日本語ロケールを使うアプレットなどで役に立ちます。


ストリーム入出力
Java 2 プラットフォームでは、文字データ処理機能を向上させるため、java.io パッケージに機能が追加されています。それは、Reader クラスと Writer クラスの追加、および PrintStream クラスに対する拡張です。

Reader クラスと Writer クラス
Reader クラスと Writer クラスの階層は、文字ストリームで入出力操作を行う機能を提供します。これらの階層は、InputStream クラスと OutputStream クラスの階層と並列になっていますが、バイトのストリームではなく、文字のストリームを処理します。文字ストリームを使うと、特定の文字エンコーディングに依存しないプログラムを簡単に記述でき、したがって、国際化も簡単になります。Reader クラスと Writer クラスには、Unicode とほかの文字エンコーディングの間の変換を行う機能もあります。Reader クラスと Writer クラスの階層の詳細については、「文字ストリーム (JDK 1.1 から導入)」を参照してください。

PrintStream クラス
PrintStream クラスは、システムのデフォルトの文字エンコーディングと行末記号を使って出力を生成します。この変更により、System.out.println() などのメソッドは、ASCII 以外のデータをより適切に処理できます。

文字分類
Java プラットフォームは、国際的な文字セット標準である Unicode で文字データを格納します。Unicode 標準は、16 ビットのエンコーディングを使って、世界の主要な書記体系のすべておよび基本的な学術記号をサポートしています。ほとんどの Java コードは、7 ビット標準の ASCII または 8 ビット標準の ISO-Latin-1 で記述されていますが、処理の前に Unicode に変換されます。したがって、Java の文字セットは常に Unicode で表現されます。
JDK ソフトウェアの Version 1.0 では、char プリミティブ型に対するオブジェクトラッパーとして、Character クラスが導入されました。Character クラスには、isLowerCase() や isDigit() など、文字のプロパティを判定するための static メソッドが含まれていました。JDK ソフトウェアの Version 1.1 では、このメソッド群が拡張されて、Unicode 2.1 で定義されているすべての文字プロパティにアクセスできるようになっています。



インプットメソッド
インプットメソッドは、キーボードによる単純入力以外の方法でテキストを入力するためのソフトウェアコンポーネントです。インプットメソッドは、多くの種類の文字が必要な日本語、中国語、または韓国語を、文字数よりはるかにキー数が少ないキーボードから入力する方式として普及しています。Java 2 プラットフォームでは、この 3 言語以外のインプットメソッドもサポートされており、手書き、音声認識などの異なる入力機構にも使用できます。
また、Windows または Solaris などのホストオペレーティングシステムから提供されるネイティブインプットメソッドを使うことができるほか、Java プログラミング言語で記述されたインプットメソッドを実装して使うこともできます。

インプットメソッドという用語は、Java プログラミング言語のクラスメソッドを指しているのではありません。


Swing でのインプットメソッドのサポート
Swing テキストコンポーネントは、インプットメソッドを使ったテキスト入力のための統合ユーザインタフェースを提供します。ロケールに応じて、オンザスポットまたはビロウザスポット入力方式が使用されます。ほとんどのロケールで使用されているオンザスポット (インライン) 入力の場合、インプットメソッドはテキストを入力している間テキストをテキストコンポーネントに直接挿入します。中国語圏のロケールで使用されているビロウザスポットテキスト入力の場合は、独立した変換ウィンドウが使用されます。このウィンドウは、確定したテキストの挿入位置の近くに自動的に配置されます。
Swing テキストコンポーネントを使用するアプリケーションでは、テキストコンポーネントとインプットメソッド間のインタラクションを調整する必要はありません。ただし、ドキュメントを保存または印刷する場合など、すべてのテキストの確定が必要な場合は、InputContext.endComposition を呼び出す必要があります。


Input Method Framework
Input Method Framework は、テキスト編集時に、テキスト編集コンポーネントとインプットメソッドインプットメソッド間の共同作業を可能にします。このフレームワークを使用するのは、テキスト編集コンポーネントまたはインプットメソッドを開発するプログラマです。その他のアプリケーション開発者は、通常はほとんど使用しません。たとえば、ドキュメントを保存または印刷する場合など、すべてのテキストの確定が必要な場合は、InputContext.endComposition を呼び出す必要があります。
「Input Method Framework」のページから、仕様および API ドキュメントへのリンクがご利用になれます。





--------------------------------------------------------------------------------
目次 
--------------------------------------------------------------------------------

java-intl@java.sun.com 
Copyright © 1996-2000 Sun Microsystems, Inc. All rights reserved.