# Bug report 1761

Begin;
Initialize;
InitializeSession  "TESTDB";
Command "create database TESTDB";
TerminateSession;
InitializeSession  "TESTDB";
Command "create table T(f1_int_btree int, f2_int int, f3_bigint bigint, f4_bigint_btree bigint, f5_float_btree float, f6_float float, f7_char varchar(10), f8_char_btree varchar(10), f9_nchar_btree nvarchar(10), f10_nchar nvarchar(10), f11_int_btree int, f12_bigint_btree bigint, f13_float float, f14_char_btree varchar(10), f15_nchar_btree nvarchar(10))";
Command "create  index I_T_f1_int_btree on T(f1_int_btree)";
Command "create  index I_T_f4_bigint_btree on T(f4_bigint_btree)";
Command "create  index I_T_f5_float_btree on T(f5_float_btree)";
Command "create  index I_T_f8_char_btree on T(f8_char_btree)";
Command "create  index I_T_f9_nchar_btree on T(f9_nchar_btree)";
Command "create  index I_T_f11_int_btree on T(f11_int_btree)";
Command "create  index I_T_f12_bigint_btree on T(f12_bigint_btree)";
Command "create  index I_T_f14_char_btree on T(f14_char_btree)";
Command "create  index I_T_f15_nchar_btree on T(f15_nchar_btree)";
Command "insert T values (?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?),(?,?,?,?,?,?,?,?,?,?,?,?,?,?,?)" [-34567890,-34567890,"-1",null,null,"0",null,"Database management systems are usually categorized according to the data model that they support: relational, object-relational, network, and so on.","コンピュータ上では、データの再利用を高速かつ安定に実現するため、データを格納するための構造について様々な工夫が払われており、このデータ構造とアルゴリズムは情報工学において重要な研究分野のひとつである。",null,null,null,null,"Database management systems are usually categorized according to the data model that they support: relational, object-relational, network, and so on.","データベース 出典: フリー百科事典『ウィキペディア（Wikipedia）』 データベース (Database) は、特定のテーマに沿ったデータを集めて管理し、容易に検索・抽出などの再利用をできるようにしたもの。 狭義には、コンピュータによって実現されたものを言う。OSが提供するファイルシステム上に直接構築されるものや、後述するデータベースマネージメントシステム (DBMS) を用いて構築されるものを含む。",2147483647,null,"876543210","-1",null,"3.141592",null," The data model will tend to determine the query languages that are available to access the database.",null,null,null,null,"0",null,"コンピュータ上では、データの再利用を高速かつ安定に実現するため、データを格納するための構造について様々な工夫が払われており、このデータ構造とアルゴリズムは情報工学において重要な研究分野のひとつである。",-2147483648,2147483647,"-5678901234567890",null,null,"3.776E3",null," A great deal of the internal engineering of a DBMS, however, is independent of the data model, and is concerned with managing factors such as performance, concurrency, integrity, and recovery from hardware failures.","単純なファイルシステムには、ファイルシステム自体に「データ」を統一的手法で操作する機能はない。ファイルシステムでデータ管理をするためには、データの操作機能を「応用プログラム側」に持つしかない。データベースは、それを自ら持つことにより、応用プログラム側でデータの物理的格納状態を知らずとも操作でき、かつ、データの物理的格納状態に変更があった場合にも応用プログラム側の処理に影響が及ばないことを保障することがデータベースの前提条件となっている。(プログラムとデータの独立性)",null,null,null,null," The data model will tend to determine the query languages that are available to access the database.","単純なファイルシステムには、ファイルシステム自体に「データ」を統一的手法で操作する機能はない。ファイルシステムでデータ管理をするためには、データの操作機能を「応用プログラム側」に持つしかない。データベースは、それを自ら持つことにより、応用プログラム側でデータの物理的格納状態を知らずとも操作でき、かつ、データの物理的格納状態に変更があった場合にも応用プログラム側の処理に影響が及ばないことを保障することがデータベースの前提条件となっている。(プログラムとデータの独立性)",0,null,"9223372036854775807","-5678901234567890",null,"1.79769313486231E308",null," In these areas there are large differences between products'.",null,null,null,null,"3.141592",null,"データベースをコンピュータ上で管理するためのシステム（Oracle Database、SQL Server、PostgreSQL、MySQL、SQLiteなど）をデータベースマネージメントシステム（DBMS）という。",1,-2147483648,"-9223372036854775808",null,null,"-1.79769313486231E308",null,"Database From Wikipedia, the free encyclopedia The term or expression database originated within the computer industry.","データベースをコンピュータ上で管理するためのシステム（Oracle Database、SQL Server、PostgreSQL、MySQL、SQLiteなど）をデータベースマネージメントシステム（DBMS）という。",null,null,null,null," A great deal of the internal engineering of a DBMS, however, is independent of the data model, and is concerned with managing factors such as performance, concurrency, integrity, and recovery from hardware failures.","データベース 出典: フリー百科事典『ウィキペディア（Wikipedia）』 データベース (Database) は、特定のテーマに沿ったデータを集めて管理し、容易に検索・抽出などの再利用をできるようにしたもの。 狭義には、コンピュータによって実現されたものを言う。OSが提供するファイルシステム上に直接構築されるものや、後述するデータベースマネージメントシステム (DBMS) を用いて構築されるものを含む。",-1,6543210,"0","9223372036854775807",null,"2.22507385850721E-308",null," Although its meaning has been broadened by popular use, even to include non-electronic databases, this article takes a more technical perspective towards the topic.","データベース 出典: フリー百科事典『ウィキペディア（Wikipedia）』 データベース (Database) は、特定のテーマに沿ったデータを集めて管理し、容易に検索・抽出などの再利用をできるようにしたもの。 狭義には、コンピュータによって実現されたものを言う。OSが提供するファイルシステム上に直接構築されるものや、後述するデータベースマネージメントシステム (DBMS) を用いて構築されるものを含む。",null,null,null,"1.79769313486231E308",null,"コンピュータ上では、データの再利用を高速かつ安定に実現するため、データを格納するための構造について様々な工夫が払われており、このデータ構造とアルゴリズムは情報工学において重要な研究分野のひとつである。",6543210,null,"1",null,null,"-2.22507385850721E-308",null," A possible definition is that a database is a structured collection of records or data which is stored in a computer so that a program can consult it to answer queries.",null,null,null,null,null," In these areas there are large differences between products'.","単純なファイルシステムには、ファイルシステム自体に「データ」を統一的手法で操作する機能はない。ファイルシステムでデータ管理をするためには、データの操作機能を「応用プログラム側」に持つしかない。データベースは、それを自ら持つことにより、応用プログラム側でデータの物理的格納状態を知らずとも操作でき、かつ、データの物理的格納状態に変更があった場合にも応用プログラム側の処理に影響が及ばないことを保障することがデータベースの前提条件となっている。(プログラムとデータの独立性)",-34567890,0,"-1","-9223372036854775808",null,"0",null," The records retrieved in answer to queries become information that can be used to make decisions.","コンピュータ上では、データの再利用を高速かつ安定に実現するため、データを格納するための構造について様々な工夫が払われており、このデータ構造とアルゴリズムは情報工学において重要な研究分野のひとつである。",null,null,null,"-1.79769313486231E308","Database From Wikipedia, the free encyclopedia The term or expression database originated within the computer industry.","データベースをコンピュータ上で管理するためのシステム（Oracle Database、SQL Server、PostgreSQL、MySQL、SQLiteなど）をデータベースマネージメントシステム（DBMS）という。",2147483647,null,"876543210","876543210",null,"3.141592",null," The computer program used to manage and query a database is known as a database management system (DBMS).",null,null,null,null,null,null,"データベース 出典: フリー百科事典『ウィキペディア（Wikipedia）』 データベース (Database) は、特定のテーマに沿ったデータを集めて管理し、容易に検索・抽出などの再利用をできるようにしたもの。 狭義には、コンピュータによって実現されたものを言う。OSが提供するファイルシステム上に直接構築されるものや、後述するデータベースマネージメントシステム (DBMS) を用いて構築されるものを含む。",-2147483648,1,"-5678901234567890",null,null,"3.776E3",null," The properties and design of database systems are included in the study of information science.","単純なファイルシステムには、ファイルシステム自体に「データ」を統一的手法で操作する機能はない。ファイルシステムでデータ管理をするためには、データの操作機能を「応用プログラム側」に持つしかない。データベースは、それを自ら持つことにより、応用プログラム側でデータの物理的格納状態を知らずとも操作でき、かつ、データの物理的格納状態に変更があった場合にも応用プログラム側の処理に影響が及ばないことを保障することがデータベースの前提条件となっている。(プログラムとデータの独立性)",null,null,null,"2.22507385850721E-308"," Although its meaning has been broadened by popular use, even to include non-electronic databases, this article takes a more technical perspective towards the topic.","コンピュータ上では、データの再利用を高速かつ安定に実現するため、データを格納するための構造について様々な工夫が払われており、このデータ構造とアルゴリズムは情報工学において重要な研究分野のひとつである。"];
TerminateSession;
InitializeSession  "TESTDB";
CreatePreparedCommand "sel1" "select count( *) from T";
PreparedCommand "sel1" [];
PreparedCommand "sel1" [];
ErasePreparedCommand "sel1";
CreatePreparedCommand "sel3" "select count(all T.f1_int_btree) from (select * from T order by f1_int_btree limit 10) as T where f2_int > -5000000 group by (T.f2_int)";
PreparedCommand "sel3" [];
PreparedCommand "sel3" [];
ErasePreparedCommand "sel3";
Command "select avg(distinct T.f1_int_btree) from T where f1_int_btree > -5000000 group by (T.f2_int)";
Command "select count( T.f2_int) from T inner join T as Tjoin using (f1_int_btree) group by (T.f2_int)";
CreatePreparedCommand "sel6" "select avg( T.f2_int) from (select * from T order by f1_int_btree limit 10) as T where f1_int_btree > -5000000";
PreparedCommand "sel6" [];
PreparedCommand "sel6" [];
ErasePreparedCommand "sel6";
CreatePreparedCommand "sel7" "select sum(distinct T.f3_bigint) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000 group by (T.f3_bigint)";
PreparedCommand "sel7" [];
PreparedCommand "sel7" [];
ErasePreparedCommand "sel7";
Command "select max(all T.f3_bigint) from T";
CreatePreparedCommand "sel9" "select sum( T.f4_bigint_btree) from T where f4_bigint_btree > 0 group by (T.f1_int_btree)";
PreparedCommand "sel9" [];
PreparedCommand "sel9" [];
ErasePreparedCommand "sel9";
Command "select max(distinct T.f4_bigint_btree) from (select * from T order by f1_int_btree limit 10) as T group by (T.f4_bigint_btree)";
Command "select sum(all T.f5_float_btree) from (select * from T order by f1_int_btree limit 10) as T group by (T.f1_int_btree)";
CreatePreparedCommand "sel12" "select max( T.f5_float_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f5_float_btree > 0";
PreparedCommand "sel12" [];
PreparedCommand "sel12" [];
ErasePreparedCommand "sel12";
Command "select min(all T.f6_float) from T where f1_int_btree > -5000000 group by (T.f6_float)";
CreatePreparedCommand "sel14" "select min( T.f6_float) from (select * from T order by f1_int_btree limit 10) as T where f6_float > 0";
PreparedCommand "sel14" [];
PreparedCommand "sel14" [];
ErasePreparedCommand "sel14";
CreatePreparedCommand "sel15" "select min(distinct T.f7_char) from T inner join T as Tjoin using (f1_int_btree) group by (T.f1_int_btree)";
PreparedCommand "sel15" [];
PreparedCommand "sel15" [];
ErasePreparedCommand "sel15";
Command "select max(all T.f7_char) from T where f1_int_btree > -5000000";
Command "select count( T.f8_char_btree) from T where f8_char_btree like 'Although%' group by (T.f8_char_btree)";
CreatePreparedCommand "sel18" "select max(distinct T.f8_char_btree) from (select * from T order by f1_int_btree limit 10) as T";
PreparedCommand "sel18" [];
PreparedCommand "sel18" [];
ErasePreparedCommand "sel18";
Command "select max(all T.f9_nchar_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000";
CreatePreparedCommand "sel20" "select max( T.f9_nchar_btree) from (select * from T order by f1_int_btree limit 10) as T where f9_nchar_btree like 'DBMS%' group by (T.f1_int_btree)";
PreparedCommand "sel20" [];
PreparedCommand "sel20" [];
ErasePreparedCommand "sel20";
CreatePreparedCommand "sel21" "select min(all T.f10_nchar) from (select * from T order by f1_int_btree limit 10) as T where f10_nchar like 'DBMS%' group by (T.f10_nchar)";
PreparedCommand "sel21" [];
PreparedCommand "sel21" [];
ErasePreparedCommand "sel21";
Command "select count(distinct T.f10_nchar) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000 group by (T.f1_int_btree)";
Command "select min( T.f11_int_btree) from T group by (T.f1_int_btree)";
CreatePreparedCommand "sel24" "select count(all T.f11_int_btree) from (select * from T order by f1_int_btree limit 10) as T where f11_int_btree > 0";
PreparedCommand "sel24" [];
PreparedCommand "sel24" [];
ErasePreparedCommand "sel24";
CreatePreparedCommand "sel25" "select avg( T.f12_bigint_btree) from T where f1_int_btree > -5000000 group by (T.f12_bigint_btree)";
PreparedCommand "sel25" [];
PreparedCommand "sel25" [];
ErasePreparedCommand "sel25";
Command "select sum(distinct T.f12_bigint_btree) from (select * from T order by f1_int_btree limit 10) as T where f12_bigint_btree > -700000000";
Command "select avg(all T.f13_float) from T inner join T as Tjoin using (f1_int_btree) group by (T.f1_int_btree)";
CreatePreparedCommand "sel28" "select sum( T.f13_float) from T where f1_int_btree > -5000000 group by (T.f13_float)";
PreparedCommand "sel28" [];
PreparedCommand "sel28" [];
ErasePreparedCommand "sel28";
CreatePreparedCommand "sel29" "select max(distinct T.f14_char_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000 group by (T.f1_int_btree)";
PreparedCommand "sel29" [];
PreparedCommand "sel29" [];
ErasePreparedCommand "sel29";
Command "select min( T.f14_char_btree) from (select * from T order by f1_int_btree limit 10) as T";
Command "select min(distinct T.f15_nchar_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000";
CreatePreparedCommand "sel32" "select max( T.f15_nchar_btree) from (select * from T order by f1_int_btree limit 10) as T group by (T.f15_nchar_btree)";
PreparedCommand "sel32" [];
PreparedCommand "sel32" [];
ErasePreparedCommand "sel32";
CreatePreparedCommand "sel34" "select max( T.f1_int_btree) from T inner join T as Tjoin using (f1_int_btree) group by (T.f1_int_btree)";
PreparedCommand "sel34" [];
PreparedCommand "sel34" [];
ErasePreparedCommand "sel34";
Command "select sum(distinct T.f2_int) from T where f2_int > -5000000 group by (T.f1_int_btree)";
Command "select count( T.f3_bigint) from (select * from T order by f1_int_btree limit 10) as T where f3_bigint > 0 group by (T.f1_int_btree)";
CreatePreparedCommand "sel37" "select count(all T.f4_bigint_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000";
PreparedCommand "sel37" [];
PreparedCommand "sel37" [];
ErasePreparedCommand "sel37";
CreatePreparedCommand "sel38" "select avg(distinct T.f5_float_btree) from T where f1_int_btree > -5000000 group by (T.f5_float_btree)";
PreparedCommand "sel38" [];
PreparedCommand "sel38" [];
ErasePreparedCommand "sel38";
Command "select avg(distinct T.f6_float) from T inner join T as Tjoin using (f1_int_btree) group by (T.f1_int_btree)";
Command "select count( T.f7_char) from (select * from T order by f1_int_btree limit 10) as T where f7_char like 'TRMeister%' group by (T.f7_char)";
CreatePreparedCommand "sel41" "select min(all T.f8_char_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000 group by (T.f1_int_btree)";
PreparedCommand "sel41" [];
PreparedCommand "sel41" [];
ErasePreparedCommand "sel41";
CreatePreparedCommand "sel42" "select max(distinct T.f9_nchar_btree) from T group by (T.f9_nchar_btree)";
PreparedCommand "sel42" [];
PreparedCommand "sel42" [];
ErasePreparedCommand "sel42";
Command "select max( T.f10_nchar) from T";
Command "select sum(distinct T.f11_int_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000 group by (T.f11_int_btree)";
CreatePreparedCommand "sel45" "select max(all T.f12_bigint_btree) from T inner join T as Tjoin using (f1_int_btree) group by (T.f1_int_btree)";
PreparedCommand "sel45" [];
PreparedCommand "sel45" [];
ErasePreparedCommand "sel45";
Command "select max(distinct T.f13_float) from (select * from T order by f1_int_btree limit 10) as T where f13_float > 0";
CreatePreparedCommand "sel47" "select count(all T.f14_char_btree) from T where f14_char_btree like 'Although%' group by (T.f14_char_btree)";
PreparedCommand "sel47" [];
PreparedCommand "sel47" [];
ErasePreparedCommand "sel47";
CreatePreparedCommand "sel48" "select max(all T.f15_nchar_btree) from T where f15_nchar_btree like 'DBMS%' group by (T.f1_int_btree)";
PreparedCommand "sel48" [];
PreparedCommand "sel48" [];
ErasePreparedCommand "sel48";
Command "select min(distinct T.f1_int_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000";
CreatePreparedCommand "sel50" "select min(all T.f2_int) from T group by (T.f2_int)";
PreparedCommand "sel50" [];
PreparedCommand "sel50" [];
ErasePreparedCommand "sel50";
CreatePreparedCommand "sel52" "select avg( T.f3_bigint) from (select * from T order by f1_int_btree limit 10) as T where f1_int_btree > -5000000";
PreparedCommand "sel52" [];
PreparedCommand "sel52" [];
ErasePreparedCommand "sel52";
Command "select min( T.f4_bigint_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f4_bigint_btree > 0 group by (T.f4_bigint_btree)";
Command "select count(distinct T.f5_float_btree) from T";
CreatePreparedCommand "sel55" "select max(distinct T.f6_float) from T where f1_int_btree > -5000000 group by (T.f6_float)";
PreparedCommand "sel55" [];
PreparedCommand "sel55" [];
ErasePreparedCommand "sel55";
CreatePreparedCommand "sel56" "select max( T.f7_char) from T inner join T as Tjoin using (f1_int_btree) where T.f7_char like 'TRMeister%'";
PreparedCommand "sel56" [];
PreparedCommand "sel56" [];
ErasePreparedCommand "sel56";
Command "select max(all T.f8_char_btree) from T group by (T.f1_int_btree)";
Command "select count(distinct T.f9_nchar_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000 group by (T.f1_int_btree)";
CreatePreparedCommand "sel59" "select max(all T.f10_nchar) from (select * from T order by f1_int_btree limit 10) as T where f10_nchar like 'DBMS%' group by (T.f10_nchar)";
PreparedCommand "sel59" [];
PreparedCommand "sel59" [];
ErasePreparedCommand "sel59";
CreatePreparedCommand "sel60" "select avg(all T.f11_int_btree) from (select * from T order by f1_int_btree limit 10) as T where f1_int_btree > -5000000 group by (T.f11_int_btree)";
PreparedCommand "sel60" [];
PreparedCommand "sel60" [];
ErasePreparedCommand "sel60";
Command "select min(distinct T.f12_bigint_btree) from (select * from T order by f1_int_btree limit 10) as T where f1_int_btree > -5000000 group by (T.f1_int_btree)";
CreatePreparedCommand "sel62" "select count( T.f13_float) from T inner join T as Tjoin using (f1_int_btree) group by (T.f1_int_btree)";
PreparedCommand "sel62" [];
PreparedCommand "sel62" [];
ErasePreparedCommand "sel62";
Command "select max( T.f14_char_btree) from (select * from T order by f1_int_btree limit 10) as T where f1_int_btree > -5000000 group by (T.f1_int_btree)";
Command "select max(distinct T.f15_nchar_btree) from T where f15_nchar_btree like 'DBMS%' group by (T.f1_int_btree)";
CreatePreparedCommand "sel66" "select sum(all T.f1_int_btree) from T";
PreparedCommand "sel66" [];
PreparedCommand "sel66" [];
ErasePreparedCommand "sel66";
CreatePreparedCommand "sel67" "select max(all T.f2_int) from T inner join T as Tjoin using (f1_int_btree) where T.f2_int > -5000000 group by (T.f1_int_btree)";
PreparedCommand "sel67" [];
PreparedCommand "sel67" [];
ErasePreparedCommand "sel67";
CreatePreparedCommand "sel68" "select min(all T.f3_bigint) from T group by (T.f1_int_btree)";
PreparedCommand "sel68" [];
PreparedCommand "sel68" [];
ErasePreparedCommand "sel68";
Command "select avg(all T.f4_bigint_btree) from (select * from T order by f1_int_btree limit 10) as T";
Command "select min(all T.f5_float_btree) from (select * from T order by f1_int_btree limit 10) as T where f5_float_btree > 0 group by (T.f5_float_btree)";
Command "select count(all T.f6_float) from T inner join T as Tjoin using (f1_int_btree) group by (T.f1_int_btree)";
Command "select sum( T.f6_float) from (select * from T order by f1_int_btree limit 10) as T where f6_float > 0";
Command "select max(distinct T.f7_char) from (select * from T order by f1_int_btree limit 10) as T where f1_int_btree > -5000000 group by (T.f7_char)";
CreatePreparedCommand "sel74" "select max(distinct T.f8_char_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f8_char_btree like 'Although%'";
PreparedCommand "sel74" [];
PreparedCommand "sel74" [];
ErasePreparedCommand "sel74";
Command "select min( T.f9_nchar_btree) from (select * from T order by f1_int_btree limit 10) as T where f9_nchar_btree like 'DBMS%' group by (T.f9_nchar_btree)";
CreatePreparedCommand "sel76" "select max(distinct T.f10_nchar) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000 group by (T.f1_int_btree)";
PreparedCommand "sel76" [];
PreparedCommand "sel76" [];
ErasePreparedCommand "sel76";
CreatePreparedCommand "sel77" "select max(distinct T.f11_int_btree) from T inner join T as Tjoin using (f1_int_btree) group by (T.f1_int_btree)";
PreparedCommand "sel77" [];
PreparedCommand "sel77" [];
ErasePreparedCommand "sel77";
Command "select count(all T.f12_bigint_btree) from T group by (T.f12_bigint_btree)";
Command "select min(distinct T.f13_float) from T where f13_float > 0 group by (T.f13_float)";
CreatePreparedCommand "sel80" "select max(distinct T.f14_char_btree) from T";
PreparedCommand "sel80" [];
PreparedCommand "sel80" [];
ErasePreparedCommand "sel80";
Command "select count( T.f15_nchar_btree) from T inner join T as Tjoin using (f1_int_btree) where T.f1_int_btree > -5000000 group by (T.f15_nchar_btree)";
TerminateSession;
InitializeSession  "TESTDB";
Command "drop database TESTDB";
TerminateSession;
Terminate;
End;
